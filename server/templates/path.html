<!DOCTYPE html>
<html lang="en">
	<head>
		<title>Path Editor</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="{{ url_for('static', filename='three.js/examples/main.css') }}">
        <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.0.1/socket.io.js" integrity="sha512-q/dWJ3kcmjBLU4Qc47E4A9kTB4m3wuTY7vkFJDTZKjTs8jhyGQnaUrxa0Ytd0ssMZhbNua9hE+E7Qv1j+DyZwA==" crossorigin="anonymous"></script>
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.3.1/dist/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css">

        <style>
			overflow: hidden;
			body {
				background-color: #f0f0f0;
				color: #444;
				--cupertino-pane-color: #000000;
				--cupertino-pane-background: #e9e9e9;
			}
			a {
				color: #08f;
			}
            
			.pane {
				max-width: 95% !important;
			}
			.list-group-item {
				cursor: default;
			}

			
		</style>
	</head>
	<body>
		<div class="fixed-top">
            <nav class="nav my-1">
                <ul class="nav mr-auto">
					<a class="nav-item active mx-1">
                        <button id="status" class="btn btn-dark btn-lg" type="button">
                            Status: UNKNOWN
                        </button>
                    </a>
                    <a class="nav-item active mx-1">
                        <button class="btn btn-dark btn-lg" type="button" data-toggle="modal" data-target="#batteryModal">
							<div class="d-flex flex-row">
								<i class="fa fa-solid fa-battery-full" style="padding: 5px 0px;"></i>
								<div id="ron-battery" style="padding: 0px 10px;">
									000 V
								</div>
							</div>
						</button>
                    </a>
                    <a>
                        <button id="pauseResumeBtn" class="btn btn-dark btn-lg" type="button" onclick="pauseResume()">
							<div class="d-flex flex-row">
								<i class="fa fa-solid fa-location-crosshairs" style="padding: 5px 0px;"></i>
								<div id="localization" style="padding: 0px 10px;">
									UNKNOWN
								</div>
							</div>
						</button>
                    </a>
                </ul>
				
                <ul class="nav mx-1">
					<a class="nav-item mx-1">
						<div class="btn-group btn-group-lg" role="group">
							<button class="btn btn-success" type="button" onclick="requestState(1)">
								Start
							</button> 
							<button class="btn btn-secondary" type="button" onclick="requestState(2)">
								Reset
							</button> 
						</div>
					</a>
                    <a class="nav-item mx-1">
                        <button class="btn btn-danger btn-lg" type="button" onclick="requestState(3)">
                            ESTOP
                        </button>
                    </a>
                </ul>
            </nav>
        </div>
		
		<div id="container"></div>

		<div id="joystickCard"></div>
		<div id="video_div"></div>

		<script type="importmap">
			{
				"imports": {
					"three": "{{ url_for('static', filename='three.js/build/three.module.js') }}",
					"three/addons/": "./jsm/",
					"urdf-loaders": "{{ url_for('static', filename='urdf-loaders/javascript/src/URDFLoader.js') }}"
				}
			}
		</script>

		<script type="module" >
			import joystickComponent from "{{ url_for('static', filename='joyComponent.mjs') }}";
			joystickComponent('joystickCard');
		</script>

		<script type="module" >
			import videoComponent from "{{ url_for('static', filename='videoComponent.mjs') }}";
			videoComponent('video_div');
		</script>


		<script type="module">

			import * as THREE from 'three';
			import * as URDF from 'urdf-loaders';

			import { GUI } from "{{ url_for('static', filename='three.js/examples/jsm/libs/lil-gui.module.min.js') }}";

            import { OrbitControls } from "{{ url_for('static', filename='three.js/examples/jsm/controls/OrbitControls.js') }}";
			import { TransformControls } from "{{ url_for('static', filename='three.js/examples/jsm/controls/TransformControls.js') }}";
			// import { STLLoader } from "{{ url_for('static', filename='three.js/examples/jsm/loaders/STLLoader.js') }}";
			import { LoadingManager } from "{{ url_for('static', filename='three.js/src/loaders/LoadingManager.js') }}";

			import URDFLoader from "{{ url_for('static', filename='urdf-loaders/javascript/src/URDFLoader.js') }}";
			import { PointerURDFDragControls } from  "{{ url_for('static', filename='urdf-loaders/javascript/src/URDFDragControls.js') }}";
			import { OBJLoader } from "{{ url_for('static', filename='three.js/examples/jsm/loaders/OBJLoader.js') }}";
			import { SVGLoader } from "{{ url_for('static', filename='three.js/examples/jsm/loaders/SVGLoader.js') }}";
			import { CupertinoPane } from "{{ url_for('static', filename='panes/dist/cupertino-pane.esm.min.js') }}";

			import {
				WebGLRenderer,
				PerspectiveCamera,
				Scene,
				Mesh,
				ShadowMaterial,
				DirectionalLight,
				PCFSoftShadowMap,
				sRGBEncoding,
				Color,
				AmbientLight,
				Box3,
				MathUtils,
			} from 'three';

			let container;
			let camera, scene, renderer;
			const splineHelperObjects = [];
			let splinePointsLength = 4;
			const positions = [];
			const point = new THREE.Vector3();

			const raycaster = new THREE.Raycaster();
			const pointer = new THREE.Vector2();
			const onUpPosition = new THREE.Vector2();
			const onDownPosition = new THREE.Vector2();

			// Load robot
			let robot_model;
			let robot = new THREE.Group();

			const manager = new LoadingManager();
			const robot_urdf_loader = new URDFLoader(manager);
			robot_urdf_loader.load("{{ url_for('static', filename='RON/urdf/RON.urdf') }}", result => {

				robot_model = result;

			});

            const geometry = new THREE.BoxGeometry( 20, 20, 20 );
			
			let transformControl;
			let controls;
			let goToPoint = null;

			const ARC_SEGMENTS = 200;

			const splines = {};

			const params = {
				uniform: true,
				tension: 0.5,
				centripetal: true,
				chordal: true,
				addPoint: addPoint,
				removePoint: removePoint,
				exportSpline: exportSpline
			};

			init();
			const planeGeometry = new THREE.PlaneGeometry( 2000, 2000 );
			planeGeometry.rotateX( - Math.PI / 2 );
			const planeMaterial = new THREE.ShadowMaterial( { color: 0x000000, opacity: 0.2 } );

			const plane = new THREE.Mesh( planeGeometry, planeMaterial );
			plane.position.y = 0;
			plane.receiveShadow = true;
			scene.add( plane );

			const textureLoader = new THREE.TextureLoader();
			const texture = textureLoader.load("{{ url_for('static', filename='mesh_tex.png') }}");

			// Create a material using the texture
			const material = new THREE.MeshStandardMaterial({ map: texture });

			let ronPointer = new THREE.Group();

			var manipulating_robot = false;
			var jointsDesiredSocket = io();
            jointsDesiredSocket.on('connect', function() {
				console.log("connected to jointsDesiredSocket");
            });
           
			// wait until all the geometry has loaded to add the model to the scene
			manager.onLoad = () => {
				console.log("robot loaded");
				robot_model.traverse(c => {
					c.castShadow = true;
				});
				
				robot_model.updateMatrixWorld(true);

				//scale the robot_model to 100x its original size
				robot_model.scale.set(100, 100, 100)
				scene.add(robot_model);
			};

			const dragControls = new PointerURDFDragControls(scene, camera, renderer.domElement);

			const highlightColor = '#FFFFFF'
			const highlightMaterial = new THREE.MeshBasicMaterial({color: 0xff0000});

			const isJoint = j => {
				return j.isURDFJoint && j.jointType !== 'fixed';
			};

			const highlightLinkGeometry = (m, revert) => {
				robot_model.traverse(c => {
					c.castShadow = true;
				});
				
				const traverse = c => {
					// Set or revert the highlight color
					if (c.type === 'Mesh') {
						if (revert) {
							c.material = c.__origMaterial;
							delete c.__origMaterial;
						} else {
							c.__origMaterial = c.material;
							c.material = highlightMaterial;
						}
					}

					// Look into the children and stop if the next child is
					// another joint
					if (c === m || !isJoint(c)) {
						for (let i = 0; i < c.children.length; i++) {
							const child = c.children[i];
							if (!child.isURDFCollider) {
								traverse(c.children[i]);
							}
						}
					}
				};
				traverse(m);
			};

			dragControls.onHover = joint => {
				highlightLinkGeometry(joint, false);
			};
			dragControls.onUnhover = joint => {
				highlightLinkGeometry(joint, true);
			};
			dragControls.onDragStart = joint => {
				manipulating_robot = true;
			};
			dragControls.onDragEnd = joint => {
				manipulating_robot = false;
			};
			dragControls.updateJoint = (joint, angle) => {
				robot_model.setJointValue(joint.name, angle);
                var joint_data = {
                    joint_name: joint.name,
                    value: angle,
                    timestamp: Date.now()
                    };
                // console.log(js_data);
                jointsDesiredSocket.emit('jointDesired', JSON.stringify(joint_data));
			};

			const RON_Pointer_loader = new SVGLoader();

			RON_Pointer_loader.load(
				"{{ url_for('static', filename='ronTop.svg') }}",
				function ( data ) {
					const paths = data.paths;
					for ( let i = 0; i < paths.length; i ++ ) {
						const path = paths[ i ];
						const material = new THREE.MeshBasicMaterial( {
							color: path.color,
							side: THREE.DoubleSide,
							depthWrite: false
						} );
						const shapes = SVGLoader.createShapes( path );
						for ( let j = 0; j < shapes.length; j ++ ) {
							const shape = shapes[ j ];
							const geometry = new THREE.ShapeGeometry( shape );
							const mesh = new THREE.Mesh( geometry, material );
							mesh.scale.set( 0.5, 0.5, 0.5 );
							mesh.rotation.set( - Math.PI / 2, 0, 0);
							mesh.position.set( -25, 0, 25);
							ronPointer.add( mesh );
						}
					}
					scene.add( ronPointer );
				},
				// called when loading is in progresses
				function ( xhr ) {
					console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' );
				},
				// called when loading has errors
				function ( error ) {
					console.log( 'An error happened' );
				}
			);

			const loader = new OBJLoader();
			loader.load(
				"{{ url_for('static', filename='mesh.obj') }}",
				function ( object ) {
					object.traverse(function (child) {
					if (child instanceof THREE.Mesh) {
							child.material = material; // Apply the material to each mesh part of the object
						}
					});
					object.scale.set(100, 100, 100)
					// set matial to the object 
					scene.add( object );
				},
				function ( xhr ) {
					console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' );
				},
				function ( error ) {
					console.log( 'An error happened' );
				}
			);

			// // Create a new EventSource object
			// var source = new EventSource('/data');
            // source.onmessage = function(event) {
            //     var data = JSON.parse(event.data);

			// 	// set robot joint agles
			// 	// from incomming data
			// 	// but only if the robot is not being manipulated by the user
			// 	if (!manipulating_robot)
			// 	{
			// 		robot_model.setJointValue("arm_right_joint_1", data["actual"]["right_arm_joint_1"]);
			// 		robot_model.setJointValue("arm_left_joint_1", 	data["actual"]["left_arm_joint_1"]);
			// 	}

			// 	// if voltage is not null, set the battery icon to the correct voltage
			// 	if (data["actual"]["voltage_0"] != null)
			// 	{
			// 		document.getElementById('ron-battery').innerHTML = data["actual"]["voltage_0"].toFixed(2) + " V";
			// 	}
			// 	// console.log(data["actual"]["orientation_yaw"], data["actual"]["orientation_pitch"], data["actual"]["orientation_roll"])
			// 	let statusText = "Status: UNKNOWN";
            //     switch(data["actual"]['state']) {
            //         case 1:
            //             statusText = "Status:  IDLE  ";
            //             break;
            //         case 2:
            //             statusText = "Status: RUNNING";
            //             break;
            //         case 3:
            //             statusText = "Status:  ERROR ";
            //             break;
            //         default:
            //             statusText = "Status: UNKNOWN";
            //     }
            //     document.getElementById("status").innerHTML = statusText;
                
			// 	renderer.render( scene, camera );
            // }

        
			// Start listening for messages once the page has loaded
			var pos_source = new EventSource('/position_data');
			window.onload = function() {
        		pos_source.onmessage = function(event) {
                	var data = JSON.parse(event.data);
					console.log(data);
					// matrix x up to y up
					// let transformationMatrix = new THREE.Matrix4();
					// transformationMatrix.set(
					// -1, 0, 0, 0,
					// 	0, 0, 1, 0,
					// 	0, 1, 0, 0,
					// 	0, 0, 0, 1
					// );

					// multiply the rotation matrix by the robot's position
					let new_pos = new THREE.Vector3(data["slam"]["position_x"], data["slam"]["position_y"], data["slam"]["position_z"]);
					// new_pos.applyMatrix4(transformationMatrix);
					console.log(new_pos)
					// // Create an Euler object and convert to a Quaternion
					// const euler = new THREE.Euler(data["slam"]["roll"], data["slam"]["pitch"], data["slam"]["yaw"], 'ZYX');
					// const quaternion = new THREE.Quaternion().setFromEuler(euler);
					// const rotationMatrix = new THREE.Matrix4().makeRotationFromQuaternion(quaternion);
					// rotationMatrix.premultiply(transformationMatrix);
					// const transformedQuaternion = new THREE.Quaternion().setFromRotationMatrix(rotationMatrix);
					// const transformedEuler = new THREE.Euler().setFromQuaternion(transformedQuaternion, 'XYZ');

					// set the base_link position and rotation to the new position and rotation
					robot_model.links["base_link"].position.set(new_pos.x*100, new_pos.y*100, new_pos.z*100);
					// robot_model.links["base_link"].rotation.set(transformedEuler.x, transformedEuler.y, transformedEuler.z);

					// ronPointer.rotation.set( 0,
					// 						transformedEuler.z,
					// 						0);
					ronPointer.position.set(new_pos.x*100,
											0,
											new_pos.z*100);
		
					// localization
					let localizationText  = "Status: UNKNOWN       ";
					switch(data['position_status']) {
						case 1:
							localizationText = "Status: DEAD RECKONING";
							break;
						case 2:
							localizationText = "Status: SLAM          ";
							break;
						case 3:
							localizationText = "Status: GPS           ";
							break;
						default:
							localizationText = "Status: UNKNOWN       ";
					}
					document.getElementById("localization").innerHTML = localizationText;
					
					renderer.render( scene, camera );
				}
			}

          	function init() {

				container = document.getElementById( 'container' );

				scene = new THREE.Scene();
				scene.background = new THREE.Color( 0x000000 );

				camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 1, 10000 );
				camera.position.set( 0, 250, 1000 );
				scene.add( camera );

				scene.add( new THREE.AmbientLight( 0xf0f0f0, 3 ) );
				const light = new THREE.SpotLight( 0xffffff, 4.5 );
				light.position.set( 0, 1500, 200 );
				light.angle = Math.PI * 0.2;
				light.decay = 0;
				light.castShadow = true;
				light.shadow.camera.near = 200;
				light.shadow.camera.far = 2000;
				light.shadow.bias = - 0.000222;
				light.shadow.mapSize.width = 1024;
				light.shadow.mapSize.height = 1024;
				scene.add( light );

				const planeGeometry = new THREE.PlaneGeometry( 2000, 2000 );
				planeGeometry.rotateX( - Math.PI / 2 );
				const planeMaterial = new THREE.ShadowMaterial( { color: 0x000000, opacity: 0.2 } );

				const plane = new THREE.Mesh( planeGeometry, planeMaterial );
				plane.position.y = 0;
				plane.receiveShadow = true;
				scene.add( plane );

				const helper = new THREE.GridHelper( 2000, 200 );
				helper.position.y = 0;
				helper.material.opacity = 1;
				helper.material.transparent = true;
				scene.add( helper );

				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.shadowMap.enabled = true;
				container.appendChild( renderer.domElement );

				const gui = new GUI();

				gui.add( params, 'uniform' ).onChange( render );
				gui.add( params, 'tension', 0, 1 ).step( 0.01 ).onChange( function ( value ) {

					splines.uniform.tension = value;
					updateSplineOutline();
					render();

				} );
				gui.add( params, 'centripetal' ).onChange( render );
				gui.add( params, 'chordal' ).onChange( render );
				gui.add( params, 'addPoint' );
				gui.add( params, 'removePoint' );
				gui.add( params, 'exportSpline' );
				gui.open();

				// Controls
				controls = new OrbitControls( camera, renderer.domElement );
				controls.damping = 0.2;
				controls.mouseButtons = {
					LEFT: null,
					MIDDLE: THREE.MOUSE.ROTATE,
					RIGHT: THREE.MOUSE.PAN
				}				
				controls.addEventListener( 'change', render );

				transformControl = new TransformControls( camera, renderer.domElement );
				transformControl.addEventListener( 'change', render );
				transformControl.addEventListener( 'dragging-changed', function ( event ) {

					controls.enabled = ! event.value;

				} );
				scene.add( transformControl );

				transformControl.addEventListener( 'objectChange', function () {

					updateSplineOutline();

				} );

				// document.addEventListener( 'pointerdown', onPointerDown );
				// document.addEventListener( 'pointerup', onPointerUp );
				// document.addEventListener( 'pointermove', onPointerMove );
				// window.addEventListener( 'resize', onWindowResize );
				// renderer.domElement.addEventListener('click', onPointerClick, false);

				/*******
				 * Curves
				 *********/

				for ( let i = 0; i < splinePointsLength; i ++ ) {

					addSplineObject( positions[ i ] );

				}

				positions.length = 0;

				for ( let i = 0; i < splinePointsLength; i ++ ) {

					positions.push( splineHelperObjects[ i ].position );

				}


				const geometry = new THREE.BufferGeometry();
				geometry.setAttribute( 'position', new THREE.BufferAttribute( new Float32Array( ARC_SEGMENTS * 3 ), 3 ) );
                
				let curve = new THREE.CatmullRomCurve3( positions );
				curve.curveType = 'catmullrom';
				curve.mesh = new THREE.Line( geometry.clone(), new THREE.LineBasicMaterial( {
					color: 0xff0000,
					opacity: 0.35
				} ) );
				curve.mesh.castShadow = true;
				splines.uniform = curve;

				curve = new THREE.CatmullRomCurve3( positions );
				curve.curveType = 'centripetal';
				curve.mesh = new THREE.Line( geometry.clone(), new THREE.LineBasicMaterial( {
					color: 0x00ff00,
					opacity: 0.35
				} ) );
				curve.mesh.castShadow = true;
				splines.centripetal = curve;

				curve = new THREE.CatmullRomCurve3( positions );
				curve.curveType = 'chordal';

				curve.mesh = new THREE.Line( geometry.clone(), new THREE.LineBasicMaterial( {
					color: 0x0000ff,
					opacity: 0.35
				} ) );
				
				curve.mesh.castShadow = true;
				splines.chordal = curve;

				for ( const k in splines ) {

					const spline = splines[ k ];
					scene.add( spline.mesh );

				}

				load( [ new THREE.Vector3( 289.76843686945404, 452.51481137238443, 56.10018915737797 ),
					new THREE.Vector3( - 53.56300074753207, 171.49711742836848, - 14.495472686253045 ),
					new THREE.Vector3( - 91.40118730204415, 176.4306956436485, - 6.958271935582161 ),
					new THREE.Vector3( - 383.785318791128, 491.1365363371675, 47.869296953772746 ) ] );

				render();

			}

			function addSplineObject( position ) {

				const material = new THREE.MeshLambertMaterial( { color: Math.random() * 0xffffff } );
				const object = new THREE.Mesh( geometry, material );

				if ( position ) {
					object.position.copy( position );
				} else {
					object.position.x = Math.random() * 1000 - 500;
					object.position.y = Math.random() * 600;
					object.position.z = Math.random() * 800 - 400;
				}

				object.castShadow = true;
				object.receiveShadow = true;
				scene.add( object );
				splineHelperObjects.push( object );
				return object;

			}

			function addPoint() {

				splinePointsLength ++;

				positions.push( addSplineObject().position );

				updateSplineOutline();

				render();

			}

			function removePoint() {

				if ( splinePointsLength <= 4 ) {

					return;

				}

				const point = splineHelperObjects.pop();
				splinePointsLength --;
				positions.pop();

				if ( transformControl.object === point ) transformControl.detach();
				scene.remove( point );

				updateSplineOutline();

				render();

			}

			function updateSplineOutline() {

				for ( const k in splines ) {

					const spline = splines[ k ];

					const splineMesh = spline.mesh;
					const position = splineMesh.geometry.attributes.position;

					for ( let i = 0; i < ARC_SEGMENTS; i ++ ) {

						const t = i / ( ARC_SEGMENTS - 1 );
						spline.getPoint( t, point );
						position.setXYZ( i, point.x, point.y, point.z );

					}

					position.needsUpdate = true;

				}

			}

			function exportSpline() {

				const strplace = [];

				for ( let i = 0; i < splinePointsLength; i ++ ) {

					const p = splineHelperObjects[ i ].position;
					strplace.push( `new THREE.Vector3(${p.x}, ${p.y}, ${p.z})` );

				}

				console.log( strplace.join( ',\n' ) );
				const code = '[' + ( strplace.join( ',\n\t' ) ) + ']';
				prompt( 'copy and paste code', code );

			}

			function load( new_positions ) {
				while ( new_positions.length > positions.length ) {
					addPoint();
				}

				while ( new_positions.length < positions.length ) {
					removePoint();
				}

				for ( let i = 0; i < positions.length; i ++ ) {
					positions[ i ].copy( new_positions[ i ] );
				}
				updateSplineOutline();
			}

			function render() {
				splines.uniform.mesh.visible = params.uniform;
				splines.centripetal.mesh.visible = params.centripetal;
				splines.chordal.mesh.visible = params.chordal;
				renderer.render( scene, camera );
			}

			function onPointerDown( event ) {

				onDownPosition.x = event.clientX;
				onDownPosition.y = event.clientY;

			}

			function onPointerUp( event ) {

				onUpPosition.x = event.clientX;
				onUpPosition.y = event.clientY;

				if ( onDownPosition.distanceTo( onUpPosition ) === 0 ) {

					transformControl.detach();
					render();

				}

			}

			function onPointerClick(event) {
				// event.preventDefault();
				if ( event.button !== 0 ) return; // Only respond to left-click

				if ( transformControl.dragging ) return; // Ignore clicks that occur while using the TransformControls
				console.log(controls)
				if ( controls.enabled.dragging ) return;

				// Calculate mouse position in normalized device coordinates (-1 to +1) for both components.
				pointer.x = (event.clientX / window.innerWidth) * 2 - 1;
				pointer.y = - (event.clientY / window.innerHeight) * 2 + 1;

				// Update the raycaster with the camera and mouse position.
				raycaster.setFromCamera(pointer, camera);

				// Calculate objects intersecting the picking ray. Assuming `plane` is your ground plane.
				const intersects = raycaster.intersectObject(plane);

				// If there's an intersection, add a sphere there.
				if (intersects.length > 0) {
					const intersectPoint = intersects[0].point;
					// if goToSphere is null create a shpere else move the sphere
					if (goToPoint == null) {
						goToPoint = addSphere(intersectPoint);
						scene.add(goToPoint);
					} else {
						moveSphere(intersectPoint);
					}
				}
				if (goToPoint != null) {
					sendDesiredPositon(goToPoint.position);
				}
				render()
			}

			function moveSphere(position){
				goToPoint.position.copy(position);
			}

			function addSphere(position) {
				// Define the sphere geometry and material.
				const sphereGeometry = new THREE.SphereGeometry(5, 32, 32);
				const sphereMaterial = new THREE.MeshBasicMaterial({color: 0xff0000});

				// Create a new sphere mesh.
				const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);

				// Set the position of the sphere to the intersection point.
				sphere.position.copy(position);
				return sphere;
			}

			function sendDesiredPositon(position) {
				let xhr = new XMLHttpRequest();
                let url = "/request_position";
            
                xhr.open("POST", url, true);
            
                xhr.setRequestHeader("Content-Type", "application/json");
            
                xhr.onreadystatechange = function () {
                    if (xhr.readyState === 4 && xhr.status === 200) {
                        console.log(this.responseText);
                    }
                };

				var data = JSON.stringify({"pos_x": position.x/100.0, "pos_y": position.z/100.0});

                xhr.send(data);
            }

			function onPointerMove( event ) {

				pointer.x = ( event.clientX / window.innerWidth ) * 2 - 1;
				pointer.y = - ( event.clientY / window.innerHeight ) * 2 + 1;

				raycaster.setFromCamera( pointer, camera );

				const intersects = raycaster.intersectObjects( splineHelperObjects, false );

				if ( intersects.length > 0 ) {
					const object = intersects[ 0 ].object;
					if ( object !== transformControl.object ) {
						transformControl.attach( object );
					}
				}
			}

			function onWindowResize() {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize( window.innerWidth, window.innerHeight );
				render();
			}

		</script>

	</body>
</html>