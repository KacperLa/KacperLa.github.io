<!DOCTYPE html>
<html lang="en">
	<head>
		<title>Path Editor</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="{{ url_for('static', filename='three.js/examples/main.css') }}">
        <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.0.1/socket.io.js" integrity="sha512-q/dWJ3kcmjBLU4Qc47E4A9kTB4m3wuTY7vkFJDTZKjTs8jhyGQnaUrxa0Ytd0ssMZhbNua9hE+E7Qv1j+DyZwA==" crossorigin="anonymous"></script>
        <script src="{{ url_for('static', filename='joy.js') }}"></script>
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.3.1/dist/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css">

        <style>
			overflow: hidden;
			body {
				background-color: #f0f0f0;
				color: #444;
				--cupertino-pane-color: #000000;
				--cupertino-pane-background: #e9e9e9;
			}
			a {
				color: #08f;
			}
            #joy2Div
            {
                position: fixed;
                bottom: 100px;
                right: 50px;
                width:300px;
                height:300px;
                margin:50px
            }
            #joystick
            {
                border: 1px solid #FF0000;
            }
			.pane {
				max-width: 95% !important;
			}
			.list-group-item {
				cursor: default;
			}
		</style>
	</head>
	<body>
		<div class="fixed-top">
            <nav class="nav my-1">
                <ul class="nav mr-auto">
					<a class="nav-item active mx-1">
                        <button id="status" class="btn btn-dark btn-lg" type="button">
                            Status: UNKNOWN
                        </button>
                    </a>
                    <a class="nav-item active mx-1">
                        <button class="btn btn-dark btn-lg" type="button" data-toggle="modal" data-target="#batteryModal">
							<div class="d-flex flex-row">
								<i class="fa fa-solid fa-battery-full" style="padding: 5px 0px;"></i>
								<div id="ron-battery" style="padding: 0px 10px;">
									000 V
								</div>
							</div>
						</button>
                    </a>
                    <a>
                        <button id="pauseResumeBtn" class="btn btn-dark btn-lg" type="button" onclick="pauseResume()">
							
							<div class="d-flex flex-row">
								<i class="fa fa-solid fa-location-crosshairs" style="padding: 5px 0px;"></i>
								<div id="localization" style="padding: 0px 10px;">
									UNKNOWN
								</div>
							</div>
						</button>
                    </a>
                </ul>
				
                <ul class="nav mx-1">
					<a class="nav-item mx-1">
						<div class="btn-group btn-group-lg" role="group">
							<button class="btn btn-success" type="button" onclick="requestState(1)">
								Start
							</button> 
							<button class="btn btn-secondary" type="button" onclick="requestState(2)">
								Reset
							</button> 
						</div>
					</a>
                    <a class="nav-item mx-1">
                        <button class="btn btn-danger btn-lg" type="button" onclick="requestState(3)">
                            ESTOP
                        </button>
                    </a>
                </ul>
            </nav>
        </div>
		
		<div id="container"></div>

		<div id="joystickCard" style="display: block">
            <div id="joy2Div"></div>
        </div>

		<div class="cupertino-pane">
			<div class="row">
				<div class="col-2">
				  <div class="list-group" id="myList" role="tablist">
					<a class="list-group-item list-group-item-action active" id="list-status"   data-toggle="list" role="tab" aria-controls="Status">Status</a>
					<a class="list-group-item list-group-item-action"        id="list-pid"      data-toggle="list" role="tab" aria-controls="PID">PID</a>
					<a class="list-group-item list-group-item-action"        id="list-logs"     data-toggle="list" role="tab" aria-controls="Logs">Logs</a>
					<a class="list-group-item list-group-item-action"        id="list-settings" data-toggle="list" role="tab" aria-controls="settings">Settings</a>
				  </div>
				</div>
				<div class="col-10">
				  <div class="tab-content" id="nav-tabContent">
					<div class="tab-pane fade show active" id="list-status-info" role="tabpanel" aria-labelledby="list-status">status stuff</div>
					<div class="tab-pane fade" id="list-pid-info" role="tabpanel" aria-labelledby="list-pid">
						<form> 
							<div class="form-group row">
								<div class="form-group mx-1 col-md-2 my-auto">Pitch:</div>
								<div class="form-group mx-1 my-auto">P</div>
								<div class="form-group mx-1 col-md-2 my-auto">
									<input type="text" class="form-control" id="pP" value="0">
								</div>
								<div class="form-group mx-1 my-auto">D</div>
								<div class="form-group mx-1 col-md-2 my-auto">
									<input type="text" class="form-control" id="pD" value="0">
								</div>
							</div>
							<div class="form-group row">
								<div class="form-group mx-1 col-md-2 my-auto">Velocity:</div>
								<div class="form-group mx-1 my-auto">P</div>
								<div class="form-group mx-1 col-md-2 my-auto">
									<input type="text" class="form-control" id="vP" value="0">
								</div>
								<div class="form-group mx-1 my-auto">I</div>
								<div class="form-group mx-1 col-md-2 my-auto">
									<input type="text" class="form-control" id="vI" value="0">
								</div>
								<div class="form-group mx-1 my-auto">D</div>
								<div class="form-group mx-1 col-md-2 my-auto">
									<input type="text" class="form-control" id="vD" value="0">
								</div>
							</div>
							<div class="form-group row">
								<div class="form-group mx-1 col-md-2 my-auto">Yaw:</div>
								<div class="form-group mx-1 my-auto">P</div>
								<div class="form-group mx-1 col-md-2 my-auto">
									<input type="text" class="form-control" id="yP" value="0">
								</div>
								<div class="form-group mx-1 my-auto">D</div>
								<div class="form-group mx-1 col-md-2 my-auto">
									<input type="text" class="form-control" id="yD" value="0">
								</div>
							</div>
		
							<div class="form-group row">
								<div class="form-group mx-1 col-md-4 my-auto">Balance Point:</div>
								<div class="form-group mx-1 my-auto">Pitch</div>
								<div class="form-group mx-1 col-md-2 my-auto">
									<input type="text" class="form-control" id="pitchZero" value="0">
								</div>
							</div>
		
							<div class="form-group row">
								<div class="form-group mx-1 col-md-2 my-auto">Position:</div>
								<div class="form-group mx-1 my-auto">P</div>
								<div class="form-group mx-1 col-md-2 my-auto">
									<input type="text" class="form-control" id="dP" value="0">
								</div>
								<div class="form-group mx-1 my-auto">I</div>
								<div class="form-group mx-1 col-md-2 my-auto">
									<input type="text" class="form-control" id="dI" value="0">
								</div>
								<div class="form-group mx-1 my-auto">D</div>
								<div class="form-group mx-1 col-md-2 my-auto">
									<input type="text" class="form-control" id="dD" value="0">
								</div>
							</div>
							<div class="form-group row">
								<div class="form-group mx-1 col-md-2 my-auto">Orientation:</div>
								<div class="form-group mx-1 my-auto">P</div>
								<div class="form-group mx-1 col-md-2 my-auto">
									<input type="text" class="form-control" id="oP" value="0">
								</div>
								<div class="form-group mx-1 my-auto">I</div>
								<div class="form-group mx-1 col-md-2 my-auto">
									<input type="text" class="form-control" id="oI" value="0">
								</div>
								<div class="form-group mx-1 my-auto">D</div>
								<div class="form-group mx-1 col-md-2 my-auto">
									<input type="text" class="form-control" id="oD" value="0">
								</div>
							</div>

							<div class="form-group row">
								<div class="form-group mx-1 col-md-4 my-auto">Position Dead Zone:</div>
								<div class="form-group mx-1 my-auto">m</div>
								<div class="form-group mx-1 col-md-2 my-auto">
									<input type="text" class="form-control" id="deadZone" value="0">
								</div>
							</div>

							<div class="form-group row">
								<div class="form-group mx-auto my-auto">     
									<button class="btn btn-success" type="button" onclick="sendCoreReq()">
										GET
									</button> 
									<button class="btn btn-success" type="button" onclick="sendCorePIDSet()">
										SET
									</button>
								</div>
							</div>
						</form>
					</div>
					<div class="tab-pane fade" id="list-logs-info" role="tabpanel" aria-labelledby="list-log">log stuff</div>
					<div class="tab-pane fade" id="list-settings-info" role="tabpanel" aria-labelledby="list-settings">setting stuff</div>
				  </div>
				</div>
			  </div>
		</div>

		<script>
			function sendCorePIDSet() {
				console.log("hello");
              	let xhr = new XMLHttpRequest();
              	let url = "/request_settings";
          
              	xhr.open("POST", url, true);
          
              	xhr.setRequestHeader("Content-Type", "application/json");
          
				xhr.onreadystatechange = function () {
					console.log(this.responseText)
				};

				var data = JSON.stringify({"settings": {
												"pP": document.getElementById('pP').value,
												"pitchZero": document.getElementById('pitchZero').value,
												"pI": "0",
												"pD": document.getElementById('pD').value,
												"vP": document.getElementById('vP').value,
												"vI": document.getElementById('vI').value,
												"vD": document.getElementById('vD').value,
												"yP": document.getElementById('yP').value,
												"yI": "0",
												"yD": document.getElementById('yD').value,
												"oP": document.getElementById('oP').value,
												"oI": document.getElementById('oI').value,
												"oD": document.getElementById('oD').value,	
												"dP": document.getElementById('dP').value,
												"dI": document.getElementById('dI').value,
												"dD": document.getElementById('dD').value,
												"deadZone": document.getElementById('deadZone').value
												}
											});
            	xhr.send(data);
           	}

			function sendCoreReq(){
            	let xhr = new XMLHttpRequest();
                let url = "/request_settings";
           
                xhr.open("GET", url, true);
           
                xhr.setRequestHeader("Content-Type", "application/json");
           
                xhr.onreadystatechange = function () {
                    console.log(this.responseText)
                    if (xhr.readyState === 4 && xhr.status === 200) {
                        var data = JSON.parse(this.responseText);
                        console.log(data)
                        document.getElementById('pP').value = data['settings']['pP'];
                        document.getElementById('pD').value = data['settings']['pD'];
                        document.getElementById('vP').value = data['settings']['vP'];
						document.getElementById('vI').value = data['settings']['vI'];
						document.getElementById('vD').value = data['settings']['vD'];
						document.getElementById('yP').value = data['settings']['yP'];
						document.getElementById('yD').value = data['settings']['yD'];
						document.getElementById('pitchZero').value = data['settings']['pitchZero'];
						document.getElementById('dP').value = data['settings']['dP'];
						document.getElementById('dI').value = data['settings']['dI'];
						document.getElementById('dD').value = data['settings']['dD'];
						document.getElementById('oP').value = data['settings']['oP'];
						document.getElementById('oI').value = data['settings']['oI'];
						document.getElementById('oD').value = data['settings']['oD'];
						document.getElementById('deadZone').value = data['settings']['deadZone'];
                    }
                };
                xhr.send();
            }
			
			function requestState(state){
                let xhr = new XMLHttpRequest();
                let url = "/request_state?state=" + state;
            
                xhr.open("GET", url, true);
            
                xhr.setRequestHeader("Content-Type", "application/json");
            
                xhr.onreadystatechange = function () {
                    if (xhr.readyState === 4 && xhr.status === 200) {
                        console.log(this.responseText);
                    }
                };
                xhr.send();
            }
		</script>
		
		<script type="importmap">
			{
				"imports": {
					"three": "{{ url_for('static', filename='three.js/build/three.module.js') }}",
					"three/addons/": "./jsm/",
					"urdf-loaders": "{{ url_for('static', filename='urdf-loaders/javascript/src/URDFLoader.js') }}"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three';
			import * as URDF from 'urdf-loaders';

			import { GUI } from "{{ url_for('static', filename='three.js/examples/jsm/libs/lil-gui.module.min.js') }}";

            import { OrbitControls } from "{{ url_for('static', filename='three.js/examples/jsm/controls/OrbitControls.js') }}";
			import { TransformControls } from "{{ url_for('static', filename='three.js/examples/jsm/controls/TransformControls.js') }}";
			// import { STLLoader } from "{{ url_for('static', filename='three.js/examples/jsm/loaders/STLLoader.js') }}";
			import { LoadingManager } from "{{ url_for('static', filename='three.js/src/loaders/LoadingManager.js') }}";

			import URDFLoader from "{{ url_for('static', filename='urdf-loaders/javascript/src/URDFLoader.js') }}";
			// import { OBJLoader } from "{{ url_for('static', filename='three.js/examples/jsm/loaders/OBJLoader.js') }}";
			import { SVGLoader } from "{{ url_for('static', filename='three.js/examples/jsm/loaders/SVGLoader.js') }}";
			import { CupertinoPane } from "{{ url_for('static', filename='panes/dist/cupertino-pane.esm.min.js') }}";

			import {
				WebGLRenderer,
				PerspectiveCamera,
				Scene,
				Mesh,
				ShadowMaterial,
				DirectionalLight,
				PCFSoftShadowMap,
				sRGBEncoding,
				Color,
				AmbientLight,
				Box3,
				MathUtils,
			} from 'three';

			let container;
			let camera, scene, renderer;
			const splineHelperObjects = [];
			let splinePointsLength = 4;
			const positions = [];
			const point = new THREE.Vector3();

			const raycaster = new THREE.Raycaster();
			const pointer = new THREE.Vector2();
			const onUpPosition = new THREE.Vector2();
			const onDownPosition = new THREE.Vector2();

			// Load robot
			let robot_model;
			let robot = new THREE.Group();

			const manager = new LoadingManager();
			const robot_urdf_loader = new URDFLoader(manager);
			robot_urdf_loader.load("{{ url_for('static', filename='RON/urdf/RON.urdf') }}", result => {

				robot_model = result;

			});

            const geometry = new THREE.BoxGeometry( 20, 20, 20 );
			
			let transformControl;
			let controls;
			let goToPoint = null;

			const ARC_SEGMENTS = 200;

			const splines = {};

			const params = {
				uniform: true,
				tension: 0.5,
				centripetal: true,
				chordal: true,
				addPoint: addPoint,
				removePoint: removePoint,
				exportSpline: exportSpline
			};

			init();
			const planeGeometry = new THREE.PlaneGeometry( 2000, 2000 );
			planeGeometry.rotateX( - Math.PI / 2 );
			const planeMaterial = new THREE.ShadowMaterial( { color: 0x000000, opacity: 0.2 } );

			const plane = new THREE.Mesh( planeGeometry, planeMaterial );
			plane.position.y = 0;
			plane.receiveShadow = true;
			scene.add( plane );

			// var objects = {};

			const textureLoader = new THREE.TextureLoader();
			const texture = textureLoader.load("{{ url_for('static', filename='mesh_tex.png') }}");

			// Create a material using the texture
			const material = new THREE.MeshStandardMaterial({ map: texture });

			let ronPointer = new THREE.Group();
			// ronPointer.add( ron_body );

			// wait until all the geometry has loaded to add the model to the scene
			manager.onLoad = () => {
				console.log("robot loaded");
				// robot_model.rotation.x = -Math.PI / 2;
				// robot_model.rotation.z = Math.PI;
				robot_model.traverse(c => {
					c.castShadow = true;
				});
				// for (let i = 1; i <= 6; i++) {

				// 	robot_model.joints[`HP${ i }`].setJointValue(MathUtils.degToRad(30));
				// 	robot_model.joints[`KP${ i }`].setJointValue(MathUtils.degToRad(120));
				// 	robot_model.joints[`AP${ i }`].setJointValue(MathUtils.degToRad(-60));

				// }
				robot_model.updateMatrixWorld(true);

				//scale the robot_model to 100x its original size
				robot_model.scale.set(100, 100, 100)

				// const bb = new Box3();
				// bb.setFromObject(robot_model);

				// robot_model.position.y -= bb.min.y;
				
				scene.add(robot_model);
				// robot.add( robot_model );
				// ronPointer.add( robot );
			};



			const RON_Pointer_loader = new SVGLoader();

			RON_Pointer_loader.load(
				"{{ url_for('static', filename='ronTop.svg') }}",
				function ( data ) {
					const paths = data.paths;

					for ( let i = 0; i < paths.length; i ++ ) {
						const path = paths[ i ];

						const material = new THREE.MeshBasicMaterial( {
							color: path.color,
							side: THREE.DoubleSide,
							depthWrite: false
						} );

						const shapes = SVGLoader.createShapes( path );

						for ( let j = 0; j < shapes.length; j ++ ) {
							const shape = shapes[ j ];
							const geometry = new THREE.ShapeGeometry( shape );
							const mesh = new THREE.Mesh( geometry, material );
							mesh.scale.set( 0.5, 0.5, 0.5 );
							mesh.rotation.set( - Math.PI / 2, 0, 0);
							mesh.position.set( -25, 0, 25);
							ronPointer.add( mesh );
						}
					}
					scene.add( ronPointer );
				},
				// called when loading is in progresses
				function ( xhr ) {
					console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' );
				},
				// called when loading has errors
				function ( error ) {
					console.log( 'An error happened' );
				}
			);

			// const loader = new OBJLoader();
			// loader.load(
			// 	"{{ url_for('static', filename='mesh_gen.obj') }}",
			// 	function ( object ) {
			// 		object.traverse(function (child) {
			// 		if (child instanceof THREE.Mesh) {
			// 				child.material = material; // Apply the material to each mesh part of the object
			// 			}
			// 		});
			// 		object.scale.set(100, 100, 100)
			// 		// set matial to the object 
			// 		scene.add( object );
			// 	},
			// 	function ( xhr ) {
			// 		console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' );
			// 	},
			// 	function ( error ) {
			// 		console.log( 'An error happened' );
			// 	}
			// );

			
			var source = new EventSource('/data');
            source.onmessage = function(event) {
                var data = JSON.parse(event.data);

				// matrix x up to y up
				let transformationMatrix = new THREE.Matrix4();
				transformationMatrix.set(
				   -1, 0, 0, 0,
					0, 0, 1, 0,
					0, 1, 0, 0,
					0, 0, 0, 1
				);

				// multiply the rotation matrix by the robot's position
				let new_pos = new THREE.Vector3(data["actual"]["positionSlam_x"], data["actual"]["positionSlam_y"], data["actual"]["positionSlam_z"]);
				new_pos.applyMatrix4(transformationMatrix);


				// Create an Euler object and convert to a Quaternion
				const euler = new THREE.Euler(data["actual"]["orientation_roll"], data["actual"]["orientation_pitch"], data["actual"]["orientation_yaw"], 'ZYX');
				const quaternion = new THREE.Quaternion().setFromEuler(euler);
				const rotationMatrix = new THREE.Matrix4().makeRotationFromQuaternion(quaternion);
				rotationMatrix.premultiply(transformationMatrix);
				const transformedQuaternion = new THREE.Quaternion().setFromRotationMatrix(rotationMatrix);
				const transformedEuler = new THREE.Euler().setFromQuaternion(transformedQuaternion, 'XYZ');

				// set the base_link position and rotation to the new position and rotation
				robot_model.links["base_link"].position.set(new_pos.x*100, new_pos.y*100, new_pos.z*100);
				robot_model.links["base_link"].rotation.set(transformedEuler.x, transformedEuler.y, transformedEuler.z);

              
				ronPointer.rotation.set( 0,
										 transformedEuler.z,
										 0);
				ronPointer.position.set(new_pos.x*100,
										0,
										new_pos.z*100);
	
				document.getElementById('ron-battery').innerHTML = data["actual"]["voltage_0"].toFixed(2) + " V";
				// console.log(data["actual"]["orientation_yaw"], data["actual"]["orientation_pitch"], data["actual"]["orientation_roll"])
				let statusText = "Status: UNKNOWN";
                switch(data["actual"]['state']) {
                    case 1:
                        statusText = "Status:  IDLE  ";
                        break;
                    case 2:
                        statusText = "Status: RUNNING";
                        break;
                    case 3:
                        statusText = "Status:  ERROR ";
                        break;
                    default:
                        statusText = "Status: UNKNOWN";
                }
                document.getElementById("status").innerHTML = statusText;
                

				localization
				let localizationText     = "Status: UNKNOWN       ";
                switch(data["actual"]['positionStatus']) {
                    case 1:
						localizationText = "Status: DEAD RECKONING";
                        break;
                    case 2:
						localizationText = "Status: SLAM          ";
                        break;
                    case 3:
						localizationText = "Status: GPS           ";
                        break;
                    default:
						localizationText = "Status: UNKNOWN       ";
                }
                document.getElementById("localization").innerHTML = localizationText;
                

				renderer.render( scene, camera );
      
            }

            function hideJoystick() {
                var joystickCard = document.getElementById("joystickCard");
                if (joystickCard.style.display === "none") {
                    joystickCard.style.display = "block";
                } else {
                    joystickCard.style.display = "none";
                }
            }
            var joy2Param = { "title": "joystick", "autoReturnToCenter": true };
            var joy = new JoyStick('joy2Div', joy2Param);
            var joystickCard = document.getElementById("joystickCard");

            var joySocket = io();
            joySocket.on('connect', function() {
                joySocket.emit('joystick event', {data: 'I\'m connected!'});
            });
            setInterval(function() {
                var joystickCard = document.getElementById("joystickCard");
                if (joystickCard.style.display === "block"){
                      var js_data = {
                        x: joy.GetX(),
                        y: joy.GetY(),
                        timestamp: Date.now()
                    };
                    // console.log(js_data);
                    joySocket.emit('js', JSON.stringify(js_data));
                }
            }, 100);

			var settings = {
				initialBreak: 'bottom',
				clickBottomOpen: false,
				breaks: {
					top: { enabled: true, height: window.innerHeight - 10 },
					bottom: { enabled: true, height: 100 },
					middle: { enabled: true, height: 500, bounce: true }
				},
				// fitHeight:true,
				draggableOver: false,
				showDraggable: false,
				topperOverflow: false,
 				upperThanTop: true,
				buttonDestroy: false
			};
			const drawer = new CupertinoPane('.cupertino-pane', settings);
			drawer.present({ animated: true });

			const tabs = document.querySelectorAll('#myList a');

			tabs.forEach(tab => {
				tab.addEventListener('click', event => {
					event.preventDefault();
					tabs.forEach(tab => {
						if (tab.classList.contains('active')){
							tab.classList.remove('active');
							const oldID = tab.getAttribute('id');
							let oldElement = document.getElementById(oldID+"-info");
							oldElement.classList.remove('show', 'active');
						}
					})
					event.target.classList.add('active');
					const tabId = event.target.getAttribute('id');

					document.getElementById(tabId+"-info").classList.add('show', 'active');
				});
			});

          	function init() {

				container = document.getElementById( 'container' );

				scene = new THREE.Scene();
				scene.background = new THREE.Color( 0x000000 );

				camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 1, 10000 );
				camera.position.set( 0, 250, 1000 );
				scene.add( camera );

				scene.add( new THREE.AmbientLight( 0xf0f0f0, 3 ) );
				const light = new THREE.SpotLight( 0xffffff, 4.5 );
				light.position.set( 0, 1500, 200 );
				light.angle = Math.PI * 0.2;
				light.decay = 0;
				light.castShadow = true;
				light.shadow.camera.near = 200;
				light.shadow.camera.far = 2000;
				light.shadow.bias = - 0.000222;
				light.shadow.mapSize.width = 1024;
				light.shadow.mapSize.height = 1024;
				scene.add( light );

				const planeGeometry = new THREE.PlaneGeometry( 2000, 2000 );
				planeGeometry.rotateX( - Math.PI / 2 );
				const planeMaterial = new THREE.ShadowMaterial( { color: 0x000000, opacity: 0.2 } );

				const plane = new THREE.Mesh( planeGeometry, planeMaterial );
				plane.position.y = 0;
				plane.receiveShadow = true;
				scene.add( plane );

				const helper = new THREE.GridHelper( 2000, 200 );
				helper.position.y = 0;
				helper.material.opacity = 1;
				helper.material.transparent = true;
				scene.add( helper );

				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.shadowMap.enabled = true;
				container.appendChild( renderer.domElement );

				// console.log(container);

				// container.addEventListener('joint-mouseover', e => {
				// 	console.log(e.detail)
				// 	console.log("mouse over")
				// 	const j = document.querySelector(`li[joint-name="${ e.detail }"]`);
				// 	if (j) j.setAttribute('robot-hovered', true);

				// });

				// container.addEventListener('joint-mouseout', e => {

				// 	const j = document.querySelector(`li[joint-name="${ e.detail }"]`);
				// 	if (j) j.removeAttribute('robot-hovered');

				// });

				// let originalNoAutoRecenter;
				// container.addEventListener('manipulate-start', e => {

				// const j = document.querySelector(`li[joint-name="${ e.detail }"]`);
				// 	if (j) {
				// 		j.scrollIntoView({ block: 'nearest' });
				// 		window.scrollTo(0, 0);
				// 	}

				// 	originalNoAutoRecenter = container.noAutoRecenter;
				// 	container.noAutoRecenter = true;

				// });

				// container.addEventListener('manipulate-end', e => {

				// 	container.noAutoRecenter = originalNoAutoRecenter;

				// });

				const gui = new GUI();

				gui.add( params, 'uniform' ).onChange( render );
				gui.add( params, 'tension', 0, 1 ).step( 0.01 ).onChange( function ( value ) {

					splines.uniform.tension = value;
					updateSplineOutline();
					render();

				} );
				gui.add( params, 'centripetal' ).onChange( render );
				gui.add( params, 'chordal' ).onChange( render );
				gui.add( params, 'addPoint' );
				gui.add( params, 'removePoint' );
				gui.add( params, 'exportSpline' );
				gui.open();

				// Controls
				controls = new OrbitControls( camera, renderer.domElement );
				controls.damping = 0.2;
				controls.mouseButtons = {
					LEFT: null,
					MIDDLE: THREE.MOUSE.ROTATE,
					RIGHT: THREE.MOUSE.PAN
				}				
				controls.addEventListener( 'change', render );

				transformControl = new TransformControls( camera, renderer.domElement );
				transformControl.addEventListener( 'change', render );
				transformControl.addEventListener( 'dragging-changed', function ( event ) {

					controls.enabled = ! event.value;

				} );
				scene.add( transformControl );

				transformControl.addEventListener( 'objectChange', function () {

					updateSplineOutline();

				} );

				document.addEventListener( 'pointerdown', onPointerDown );
				document.addEventListener( 'pointerup', onPointerUp );
				document.addEventListener( 'pointermove', onPointerMove );
				window.addEventListener( 'resize', onWindowResize );
				renderer.domElement.addEventListener('click', onPointerClick, false);

				/*******
				 * Curves
				 *********/

				for ( let i = 0; i < splinePointsLength; i ++ ) {

					addSplineObject( positions[ i ] );

				}

				positions.length = 0;

				for ( let i = 0; i < splinePointsLength; i ++ ) {

					positions.push( splineHelperObjects[ i ].position );

				}


				const geometry = new THREE.BufferGeometry();
				geometry.setAttribute( 'position', new THREE.BufferAttribute( new Float32Array( ARC_SEGMENTS * 3 ), 3 ) );
                
				let curve = new THREE.CatmullRomCurve3( positions );
				curve.curveType = 'catmullrom';
				curve.mesh = new THREE.Line( geometry.clone(), new THREE.LineBasicMaterial( {
					color: 0xff0000,
					opacity: 0.35
				} ) );
				curve.mesh.castShadow = true;
				splines.uniform = curve;

				curve = new THREE.CatmullRomCurve3( positions );
				curve.curveType = 'centripetal';
				curve.mesh = new THREE.Line( geometry.clone(), new THREE.LineBasicMaterial( {
					color: 0x00ff00,
					opacity: 0.35
				} ) );
				curve.mesh.castShadow = true;
				splines.centripetal = curve;

				curve = new THREE.CatmullRomCurve3( positions );
				curve.curveType = 'chordal';

				curve.mesh = new THREE.Line( geometry.clone(), new THREE.LineBasicMaterial( {
					color: 0x0000ff,
					opacity: 0.35
				} ) );
				
				curve.mesh.castShadow = true;
				splines.chordal = curve;

				for ( const k in splines ) {

					const spline = splines[ k ];
					scene.add( spline.mesh );

				}

				load( [ new THREE.Vector3( 289.76843686945404, 452.51481137238443, 56.10018915737797 ),
					new THREE.Vector3( - 53.56300074753207, 171.49711742836848, - 14.495472686253045 ),
					new THREE.Vector3( - 91.40118730204415, 176.4306956436485, - 6.958271935582161 ),
					new THREE.Vector3( - 383.785318791128, 491.1365363371675, 47.869296953772746 ) ] );

				render();

			}

			function addSplineObject( position ) {

				const material = new THREE.MeshLambertMaterial( { color: Math.random() * 0xffffff } );
				const object = new THREE.Mesh( geometry, material );

				if ( position ) {
					object.position.copy( position );
				} else {
					object.position.x = Math.random() * 1000 - 500;
					object.position.y = Math.random() * 600;
					object.position.z = Math.random() * 800 - 400;
				}

				object.castShadow = true;
				object.receiveShadow = true;
				scene.add( object );
				splineHelperObjects.push( object );
				return object;

			}

			function addPoint() {

				splinePointsLength ++;

				positions.push( addSplineObject().position );

				updateSplineOutline();

				render();

			}

			function removePoint() {

				if ( splinePointsLength <= 4 ) {

					return;

				}

				const point = splineHelperObjects.pop();
				splinePointsLength --;
				positions.pop();

				if ( transformControl.object === point ) transformControl.detach();
				scene.remove( point );

				updateSplineOutline();

				render();

			}

			function updateSplineOutline() {

				for ( const k in splines ) {

					const spline = splines[ k ];

					const splineMesh = spline.mesh;
					const position = splineMesh.geometry.attributes.position;

					for ( let i = 0; i < ARC_SEGMENTS; i ++ ) {

						const t = i / ( ARC_SEGMENTS - 1 );
						spline.getPoint( t, point );
						position.setXYZ( i, point.x, point.y, point.z );

					}

					position.needsUpdate = true;

				}

			}

			function exportSpline() {

				const strplace = [];

				for ( let i = 0; i < splinePointsLength; i ++ ) {

					const p = splineHelperObjects[ i ].position;
					strplace.push( `new THREE.Vector3(${p.x}, ${p.y}, ${p.z})` );

				}

				console.log( strplace.join( ',\n' ) );
				const code = '[' + ( strplace.join( ',\n\t' ) ) + ']';
				prompt( 'copy and paste code', code );

			}

			function load( new_positions ) {

				while ( new_positions.length > positions.length ) {

					addPoint();

				}

				while ( new_positions.length < positions.length ) {

					removePoint();

				}

				for ( let i = 0; i < positions.length; i ++ ) {

					positions[ i ].copy( new_positions[ i ] );

				}

				updateSplineOutline();

			}

			function render() {

				splines.uniform.mesh.visible = params.uniform;
				splines.centripetal.mesh.visible = params.centripetal;
				splines.chordal.mesh.visible = params.chordal;
				renderer.render( scene, camera );

			}

			function onPointerDown( event ) {

				onDownPosition.x = event.clientX;
				onDownPosition.y = event.clientY;

			}

			function onPointerUp( event ) {

				onUpPosition.x = event.clientX;
				onUpPosition.y = event.clientY;

				if ( onDownPosition.distanceTo( onUpPosition ) === 0 ) {

					transformControl.detach();
					render();

				}

			}

			function onPointerClick(event) {
				// event.preventDefault();
				if ( event.button !== 0 ) return; // Only respond to left-click

				if ( transformControl.dragging ) return; // Ignore clicks that occur while using the TransformControls
				console.log(controls)
				if ( controls.enabled.dragging ) return;

				// Calculate mouse position in normalized device coordinates (-1 to +1) for both components.
				pointer.x = (event.clientX / window.innerWidth) * 2 - 1;
				pointer.y = - (event.clientY / window.innerHeight) * 2 + 1;

				// Update the raycaster with the camera and mouse position.
				raycaster.setFromCamera(pointer, camera);

				// Calculate objects intersecting the picking ray. Assuming `plane` is your ground plane.
				const intersects = raycaster.intersectObject(plane);

				// If there's an intersection, add a sphere there.
				if (intersects.length > 0) {
					const intersectPoint = intersects[0].point;
					// if goToSphere is null create a shpere else move the sphere
					if (goToPoint == null) {
						goToPoint = addSphere(intersectPoint);
						scene.add(goToPoint);
					} else {
						moveSphere(intersectPoint);
					}
				}
				if (goToPoint != null) {
					sendDesiredPositon(goToPoint.position);
				}
				render()
			}

			function moveSphere(position){
				goToPoint.position.copy(position);
			}

			function addSphere(position) {
				// Define the sphere geometry and material.
				const sphereGeometry = new THREE.SphereGeometry(5, 32, 32);
				const sphereMaterial = new THREE.MeshBasicMaterial({color: 0xff0000});

				// Create a new sphere mesh.
				const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);

				// Set the position of the sphere to the intersection point.
				sphere.position.copy(position);
				return sphere;
			}

			function sendDesiredPositon(position) {
				let xhr = new XMLHttpRequest();
                let url = "/request_position";
            
                xhr.open("POST", url, true);
            
                xhr.setRequestHeader("Content-Type", "application/json");
            
                xhr.onreadystatechange = function () {
                    if (xhr.readyState === 4 && xhr.status === 200) {
                        console.log(this.responseText);
                    }
                };

				var data = JSON.stringify({"pos_x": position.x/100.0, "pos_y": position.z/100.0});

                xhr.send(data);
            }

			function onPointerMove( event ) {

				pointer.x = ( event.clientX / window.innerWidth ) * 2 - 1;
				pointer.y = - ( event.clientY / window.innerHeight ) * 2 + 1;

				raycaster.setFromCamera( pointer, camera );

				const intersects = raycaster.intersectObjects( splineHelperObjects, false );

				if ( intersects.length > 0 ) {

					const object = intersects[ 0 ].object;

					if ( object !== transformControl.object ) {

						transformControl.attach( object );

					}

				}

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

				render();

			}

		</script>

	</body>
</html>